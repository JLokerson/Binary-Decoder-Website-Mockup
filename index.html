<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Binary Decoder Mockup - Gill Sans Optimized</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üîç</text></svg>">
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
    <style>
        body {
            background: linear-gradient(to bottom, #A8A8A8 0%, #4e4e4e 100%);
            min-height: 100vh;
            position: relative;
        }
        
        /* Orange button styling */
        .option-btn, .back-btn, #captureBtn {
            color: #F56600 !important;
            border: 2px solid #F56600 !important;
            background-color: white
        }
        
        .option-btn:hover, .back-btn:hover, #captureBtn:hover {
            background-color: #F56600 !important;
            color: white !important;
        }
        
        button {
            color: #F56600;
            border: 2px solid #F56600;
            background-color: transparent;
        }
        
        button:hover {
            background-color: #F56600;
            color: white;
        }
    </style>
</head>
<body> 
    <!-- Binary Background Pattern -->
    <div id="binaryBackground" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; pointer-events: none; font-family: monospace; font-size: 14px; color: rgba(255, 255, 255, 0.15); line-height: 1.2; padding: 20px; overflow: hidden; white-space: pre-wrap; word-wrap: break-word;"></div>

    <header>
        <h1>Binary Decoder Mockup</h1>
    </header>
    <div class="description">
        <p>
            This webpage uses your phone's camera or images to scan binary and converts it to ASCII text in real time. 
            <strong>Optimized for Gill Sans font recognition.</strong>
        <ul>
            <li>Camera access via WebRTC (getUserMedia)</li>
            <li>OCR powered by custom Gill Sans trained Tesseract model</li>
            <li>Real-time binary to ASCII conversion</li>
        </ul>
    </div>
    <!-- Selection Menu -->
    <div class="selection-menu" id="selectionMenu" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; max-width: 600px; margin: 0 auto; padding: 20px;">
        <button class="option-btn" id="takePhotoBtn" style="aspect-ratio: 1; min-height: 180px; display: flex; align-items: center; justify-content: center; text-align: center; padding: 30px; border-radius: 8px; font-size: 28px;">Take a Photo</button>
        <button class="option-btn" id="insertPhotoBtn" style="aspect-ratio: 1; min-height: 180px; display: flex; align-items: center; justify-content: center; text-align: center; padding: 30px; border-radius: 8px; font-size: 28px;">Insert a Photo</button>
        <button class="option-btn" id="scanCameraBtn" style="aspect-ratio: 1; min-height: 180px; display: flex; align-items: center; justify-content: center; text-align: center; padding: 30px; border-radius: 8px; font-size: 28px;">Scan from Camera Feed</button>
        <button class="option-btn" id="textInputBtn" style="aspect-ratio: 1; min-height: 180px; display: flex; align-items: center; justify-content: center; text-align: center; padding: 30px; border-radius: 8px; font-size: 28px;">Text Input</button>
    </div>
    <!-- Main Area (hidden until option selected) -->
    <div class="main-area" id="mainArea" style="display:none;">
        <button class="back-btn" id="backBtn">Back</button>
        <div class="side-by-side">
            <div class="image-area" id="imageArea">
                <video id="video" autoplay playsinline muted style="display:none;"></video>
                <canvas id="photoCanvas" style="display:none;"></canvas>
                <img id="uploadedImg" style="display:none; max-width:100%;" />
                <canvas id="processedCanvas" style="display:none; max-width:100%; border:1px solid #aaa;"></canvas>
                <button id="toggleProcessedBtn" class="option-btn" style="display:none; margin-top:8px;">Show Processed Image</button>
                <!-- Text Input Area -->
                <div id="textInputArea" style="display:none;">
                    <label for="binaryTextInput" style="font-size:1.2em; font-weight:bold; display:block; margin-bottom:8px;">Enter Binary Code:</label>
                    <textarea id="binaryTextInput" placeholder="Enter binary code here (e.g., 01001000 01100101 01101100 01101100 01101111)" 
                              style="width:100%; height:200px; font-family:monospace; font-size:14px; padding:8px; border:1px solid #ccc; border-radius:4px; resize:vertical;"></textarea>
                    <div style="margin-top:8px; font-size:0.9em; color:#666;">
                        <strong>Tips:</strong> Enter binary in 8-bit groups separated by spaces. Invalid characters will be highlighted.
                    </div>
                </div>
            </div>
            <div class="output-area" id="outputArea">
                <strong style="font-size:1.3em;">Decoded Text:</strong>
                <pre id="decodedText" style="font-size:1.2em;">// ...binary will appear here...</pre>
            </div>
        </div>
    </div>
    <!-- File input for image upload (hidden) -->
    <input type="file" id="fileInput" accept="image/*" style="display:none;" />
    
    <script>
        // Generate binary pattern background
        function generateBinaryBackground() {
            const fullBinaryString = "01010100 01101000 01101001 01110011 00100000 01110111 01100101 01100010 01110011 01101001 01110100 01100101 00100000 01110111 01100001 01110011 00100000 01101101 01100001 01100100 01100101 00100000 01100010 01111001 00100000 01001010 01110101 01101100 01101001 01100001 00100000 01001100 01101111 01101011 01100101 01110010 01110011 01101111 01101110 ";
            const backgroundDiv = document.getElementById('binaryBackground');
            
            // Calculate dimensions more accurately
            const fontSize = 14;
            const lineHeight = fontSize * 1.2; // 16.8px actual line height
            const charWidth = fontSize * 0.6; // Approximate monospace character width
            
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Calculate how many characters fit per line and how many lines we need
            const charsPerLine = Math.floor(viewportWidth / charWidth) + 10; // Extra chars for safety
            const numLines = Math.floor(viewportHeight / lineHeight) + 5; // Extra lines for safety
            
            // Create a continuous pattern that wraps seamlessly
            let fullPattern = '';
            let currentPos = 0;
            
            for (let line = 0; line < numLines; line++) {
                let lineText = '';
                let lineLength = 0;
                
                while (lineLength < charsPerLine) {
                    const remainingSpace = charsPerLine - lineLength;
                    const availableText = fullBinaryString.slice(currentPos);
                    
                    if (availableText.length === 0 || currentPos >= fullBinaryString.length) {
                        currentPos = 0; // Reset to beginning of pattern
                        continue;
                    }
                    
                    if (availableText.length >= remainingSpace) {
                        lineText += availableText.slice(0, remainingSpace);
                        currentPos += remainingSpace;
                        lineLength = charsPerLine;
                    } else {
                        lineText += availableText;
                        lineLength += availableText.length;
                        currentPos = 0; // Reset to beginning for next iteration
                    }
                }
                
                fullPattern += lineText + '\n';
            }
            
            backgroundDiv.textContent = fullPattern;
        }

        // Custom Gill Sans model configuration
        let customModelLoaded = false;
        let tesseractWorker = null;
        
        // Load custom Gill Sans model
        async function loadCustomModel() {
            try {
                // Create worker with modern v5 API
                const worker = await Tesseract.createWorker('eng', 1, {
                    logger: m => console.log(m)
                });
                
                customModelLoaded = false; // Using English model as fallback
                
                return worker;
            } catch (error) {
                console.error('Error creating Tesseract worker:', error);
                
                // Fallback worker creation
                const worker = await Tesseract.createWorker('eng');
                return worker;
            }
        }
        
        // Updated OCR functions to use modern API
        async function performOCR(imageDataUrl) {
            if (!tesseractWorker) {
                tesseractWorker = await loadCustomModel();
            }
            
            try {
                const { data: { text } } = await tesseractWorker.recognize(imageDataUrl);
                console.log("Raw Tesseract OCR result:", text);
                
                const binaryStr = text.replace(/\s+/g, ' ').trim();
                console.log("Normalized OCR text:", binaryStr);
                
                const ascii = binaryToAscii(binaryStr);
                return ascii || '// No valid binary detected';
            } catch (error) {
                console.error("OCR error:", error);
                return '// OCR error';
            }
        }

        // New UI elements
        const selectionMenu = document.getElementById('selectionMenu');
        const mainArea = document.getElementById('mainArea');
        const takePhotoBtn = document.getElementById('takePhotoBtn');
        const insertPhotoBtn = document.getElementById('insertPhotoBtn');
        const scanCameraBtn = document.getElementById('scanCameraBtn');
        const textInputBtn = document.getElementById('textInputBtn');
        const backBtn = document.getElementById('backBtn');
        const photoCanvas = document.getElementById('photoCanvas');
        const uploadedImg = document.getElementById('uploadedImg');
        const fileInput = document.getElementById('fileInput');
        const video = document.getElementById('video');
        const decodedText = document.getElementById('decodedText');
        const processedCanvas = document.getElementById('processedCanvas');
        const toggleProcessedBtn = document.getElementById('toggleProcessedBtn');
        const textInputArea = document.getElementById('textInputArea');
        const binaryTextInput = document.getElementById('binaryTextInput');
        let ocrInterval = null;
        let currentMode = null;
        let processedCanvasVisible = false;

        // Helper: Convert binary string to ASCII (more tolerant)
        function binaryToAscii(binaryStr, printableOnly = false) {
            console.log("Input binary string:", binaryStr);
            
            // More aggressive OCR error correction
            let cleaned = binaryStr
                // Common OCR mistakes for 1: l, I, |, !, 1
                .replace(/[lI|!]/g, '1')
                // Common OCR mistakes for 0: O, o, Q, D, []
                .replace(/[OoQD\[\]]/g, '0')
                // Handle mixed character sequences like "OI" -> "01", "IO" -> "10"
                .replace(/OI/g, '01')
                .replace(/IO/g, '10')
                .replace(/Ol/g, '01')
                .replace(/lO/g, '10')
                // Remove any remaining non-binary characters and whitespace inconsistencies
                .replace(/[^01\s]/g, '')
                // Normalize whitespace
                .replace(/\s+/g, ' ')
                .trim();
            
            console.log("After OCR corrections:", cleaned);
            
            // Split by whitespace and filter to only valid 8-character binary strings
            const words = cleaned.split(/\s+/).filter(word => word.length > 0);
            console.log("Split into words:", words);
            
            // Only keep exactly 8-character strings that are pure binary
            const validBinaries = words.filter(w => w.length === 8 && /^[01]{8}$/.test(w));
            
            // Log what we're keeping vs discarding
            const discarded = words.filter(w => w.length !== 8 || !/^[01]{8}$/.test(w));
            
            console.log("Valid 8-bit binary groups:", validBinaries);
            
            if (discarded.length > 0) {
                console.log("Discarded invalid sequences:", discarded);
            }
            
            if (validBinaries.length === 0) {
                console.log("No valid 8-bit binary groups found after cleaning.");
                return '';
            }
            
            // Convert binary to ASCII
            let ascii = validBinaries.map(bin => {
                const charCode = parseInt(bin, 2);
                const char = String.fromCharCode(charCode);
                console.log(`${bin} -> ${charCode} -> "${char}"`);
                return char;
            }).join('');
            
            console.log("Raw ASCII conversion:", ascii);
            
            if (printableOnly) {
                const originalLength = ascii.length;
                ascii = ascii.split('').filter(c => {
                    const code = c.charCodeAt(0);
                    return code >= 32 && code <= 126;
                }).join('');
                console.log(`Filtered to printable only: ${originalLength} ‚Üí ${ascii.length} chars`);
            }
            
            console.log("Final ASCII output:", ascii);
            return ascii;
        }

        // Hide main area, show selection menu
        function showSelectionMenu() {
            mainArea.style.display = 'none';
            selectionMenu.style.display = 'grid';
            video.style.display = 'none';
            photoCanvas.style.display = 'none';
            uploadedImg.style.display = 'none';
            textInputArea.style.display = 'none';
            decodedText.textContent = '// ...binary will appear here...';
            if (ocrInterval) clearInterval(ocrInterval);
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            // Hide capture button if present
            const captureBtn = document.getElementById('captureBtn');
            if (captureBtn) captureBtn.style.display = 'none';
        }
        // Show main area, hide selection menu
        function showMainArea(mode) {
            selectionMenu.style.display = 'none';
            mainArea.style.display = 'block';
            currentMode = mode;
        }
        // Take Photo Mode
        takePhotoBtn.onclick = async () => {
            showMainArea('photo');
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                try {
                    // Check if we're on HTTPS or localhost
                    const isSecureContext = window.isSecureContext || location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
                    
                    if (!isSecureContext) {
                        throw new Error('Camera access requires HTTPS or localhost');
                    }
                    
                    // Try recommended facingMode first
                    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
                    video.srcObject = stream;
                    video.style.display = 'block';
                    photoCanvas.style.display = 'none';
                    uploadedImg.style.display = 'none';
                    decodedText.textContent = '// ...binary will appear here...';
                    // Add "Capture" button
                    let btn = document.getElementById('captureBtn');
                    if (!btn) {
                        btn = document.createElement('button');
                        btn.id = 'captureBtn';
                        btn.textContent = 'Capture Photo';
                        btn.className = 'option-btn';
                        btn.onclick = () => {
                            photoCanvas.width = video.videoWidth || 640;
                            photoCanvas.height = video.videoHeight || 480;
                            photoCanvas.getContext('2d').drawImage(video, 0, 0, photoCanvas.width, photoCanvas.height);
                            photoCanvas.style.display = 'block';
                            video.style.display = 'none';
                            btn.style.display = 'none';
                            if (video.srcObject) {
                                video.srcObject.getTracks().forEach(track => track.stop());
                                video.srcObject = null;
                            }
                            runOcrOnCanvas(photoCanvas);
                        };
                        mainArea.insertBefore(btn, mainArea.firstChild.nextSibling);
                    } else {
                        btn.style.display = 'block';
                    }
                } catch (err) {
                    // Fallback to any camera
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                        video.srcObject = stream;
                        video.style.display = 'block';
                        photoCanvas.style.display = 'none';
                        uploadedImg.style.display = 'none';
                        decodedText.textContent = '// ...binary will appear here...';
                        let btn = document.getElementById('captureBtn');
                        if (!btn) {
                            btn = document.createElement('button');
                            btn.id = 'captureBtn';
                            btn.textContent = 'Capture Photo';
                            btn.className = 'option-btn';
                            btn.onclick = () => {
                                photoCanvas.width = video.videoWidth || 640;
                                photoCanvas.height = video.videoHeight || 480;
                                photoCanvas.getContext('2d').drawImage(video, 0, 0, photoCanvas.width, photoCanvas.height);
                                photoCanvas.style.display = 'block';
                                video.style.display = 'none';
                                btn.style.display = 'none';
                                if (video.srcObject) {
                                    video.srcObject.getTracks().forEach(track => track.stop());
                                    video.srcObject = null;
                                }
                                runOcrOnCanvas(photoCanvas);
                            };
                            mainArea.insertBefore(btn, mainArea.firstChild.nextSibling);
                        } else {
                            btn.style.display = 'block';
                        }
                    } catch (err2) {
                        console.error('Camera access error:', err2);
                        alert('Camera access denied or not available. For local development, make sure you are using http://localhost:8000 (not https).');
                        showSelectionMenu();
                    }
                }
            }
        };
        // Insert Photo Mode
        insertPhotoBtn.onclick = () => {
            showMainArea('upload');
            video.style.display = 'none';
            photoCanvas.style.display = 'none';
            uploadedImg.style.display = 'none';
            decodedText.textContent = '// ...binary will appear here...';
            fileInput.value = '';
            fileInput.click();
        };
        fileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(ev) {
                    uploadedImg.onload = function() {
                        uploadedImg.style.display = 'block';
                        photoCanvas.style.display = 'none';
                        video.style.display = 'none';
                        runOcrOnImage(uploadedImg);
                    };
                    uploadedImg.src = ev.target.result;
                };
                reader.readAsDataURL(file);
            }
        };
        // Scan from Camera Feed Mode
        scanCameraBtn.onclick = async () => {
            showMainArea('live');
            video.style.display = 'block';
            photoCanvas.style.display = 'none';
            uploadedImg.style.display = 'none';
            decodedText.textContent = '// ...binary will appear here...';
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                try {
                    // Check if we're on HTTPS or localhost
                    const isSecureContext = window.isSecureContext || location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
                    
                    if (!isSecureContext) {
                        throw new Error('Camera access requires HTTPS or localhost');
                    }
                    
                    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
                    video.srcObject = stream;
                    startOcr();
                } catch (err) {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                        video.srcObject = stream;
                        startOcr();
                    } catch (err2) {
                        console.error('Camera access error:', err2);
                        alert('Camera access denied or not available. For local development, make sure you are using http://localhost:8000 (not https) and allow camera permissions.');
                        showSelectionMenu();
                    }
                }
            } else {
                alert('Camera not supported in this browser. Make sure you are using a modern browser and http://localhost:8000 for local development.');
                showSelectionMenu();
            }
        };
        // Back button
        backBtn.onclick = () => {
            showSelectionMenu();
        };
        // Toggle processed image visibility
        toggleProcessedBtn.onclick = () => {
            processedCanvasVisible = !processedCanvasVisible;
            processedCanvas.style.display = processedCanvasVisible ? 'block' : 'none';
            toggleProcessedBtn.textContent = processedCanvasVisible ? 'Hide Processed Image' : 'Show Processed Image';
        };
        // Helper: Grayscale conversion
        function preprocessCanvas(canvas, debugCanvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            // Grayscale conversion
            for (let i = 0; i < imageData.data.length; i += 4) {
                let avg = (imageData.data[i] + imageData.data[i+1] + imageData.data[i+2]) / 3;
                imageData.data[i] = imageData.data[i+1] = imageData.data[i+2] = avg;
            }
            ctx.putImageData(imageData, 0, 0);
            // If debugging, copy to debugCanvas
            if (debugCanvas) {
                debugCanvas.width = canvas.width;
                debugCanvas.height = canvas.height;
                debugCanvas.getContext('2d').putImageData(imageData, 0, 0);
                toggleProcessedBtn.style.display = 'inline-block';
                processedCanvas.style.display = processedCanvasVisible ? 'block' : 'none';
                toggleProcessedBtn.textContent = processedCanvasVisible ? 'Hide Processed Image' : 'Show Processed Image';
            } else {
                toggleProcessedBtn.style.display = 'none';
                processedCanvas.style.display = 'none';
            }
        }
        // Helper: Minimum image/canvas size for OCR
        function isImageLargeEnough(width, height, minWidth = 3, minHeight = 36) {
            return width >= minWidth && height >= minHeight;
        }
        // OCR for still image (canvas) with preprocessing
        function runOcrOnCanvas(canvas) {
            if (!isImageLargeEnough(canvas.width, canvas.height)) {
                decodedText.textContent = '// Image too small to scan!';
                return;
            }
            
            decodedText.textContent = 'Scanning...';
            const scale = 2;
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width * scale;
            tempCanvas.height = canvas.height * scale;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(canvas, 0, 0, tempCanvas.width, tempCanvas.height);
            
            preprocessCanvas(tempCanvas, processedCanvas);
            const imageDataUrl = tempCanvas.toDataURL('image/png');
            
            performOCR(imageDataUrl).then(result => {
                decodedText.textContent = result;
            });
        }

        // OCR for uploaded image with preprocessing
        function runOcrOnImage(img) {
            const processImage = async function() {
                const scale = 2;
                const w = img.naturalWidth * scale;
                const h = img.naturalHeight * scale;
                
                if (!isImageLargeEnough(w, h)) {
                    decodedText.textContent = '// Image too small to scan!';
                    return;
                }
                
                photoCanvas.width = w;
                photoCanvas.height = h;
                const ctx = photoCanvas.getContext('2d');
                ctx.drawImage(img, 0, 0, photoCanvas.width, photoCanvas.height);
                photoCanvas.style.display = 'none';
                
                preprocessCanvas(photoCanvas, processedCanvas);
                const imageDataUrl = photoCanvas.toDataURL('image/png');
                
                decodedText.textContent = 'Scanning...';
                const result = await performOCR(imageDataUrl);
                decodedText.textContent = result;
            };
            
            if (img.complete && img.naturalWidth > 0) {
                processImage();
            } else {
                img.onload = processImage;
            }
        }

        async function startOcr() {
            const canvas = document.createElement('canvas');
            const squareSize = 640;
            canvas.width = squareSize;
            canvas.height = squareSize;
            const ctx = canvas.getContext('2d');
            
            ocrInterval = setInterval(async () => {
                if (video.readyState === video.HAVE_ENOUGH_DATA) {
                    const vw = video.videoWidth || 640;
                    const vh = video.videoHeight || 480;
                    
                    if (!isImageLargeEnough(vw, vh)) {
                        decodedText.textContent = '// Camera image too small!';
                        return;
                    }
                    
                    const sx = Math.floor((vw - squareSize) / 2);
                    const sy = Math.floor((vh - squareSize) / 2);
                    ctx.drawImage(video, sx, sy, squareSize, squareSize, 0, 0, squareSize, squareSize);
                    
                    preprocessCanvas(canvas, processedCanvas);
                    const imageDataUrl = canvas.toDataURL('image/png');
                    
                    decodedText.textContent = "Scanning...";
                    const result = await performOCR(imageDataUrl);
                    decodedText.textContent = result;
                }
            }, 1000); 
        }

        window.onload = async () => {
            generateBinaryBackground();
            showSelectionMenu();
            // Pre-load the Tesseract worker
            try {
                tesseractWorker = await loadCustomModel();
                console.log('Tesseract worker loaded successfully');
            } catch (error) {
                console.error('Failed to load Tesseract worker:', error);
            }
            
            // Regenerate background on window resize
            window.addEventListener('resize', generateBinaryBackground);
        };
        
        // Text Input Mode
        textInputBtn.onclick = () => {
            showMainArea('text');
            video.style.display = 'none';
            photoCanvas.style.display = 'none';
            uploadedImg.style.display = 'none';
            processedCanvas.style.display = 'none';
            toggleProcessedBtn.style.display = 'none';
            textInputArea.style.display = 'block';
            decodedText.textContent = '// Enter binary code in the text area...';
            binaryTextInput.focus();
        };

        // Real-time binary text conversion
        binaryTextInput.oninput = () => {
            const inputText = binaryTextInput.value;
            if (!inputText.trim()) {
                decodedText.textContent = '// Enter binary code in the text area...';
                return;
            }
            
            // Convert text input using existing binaryToAscii function
            const result = binaryToAscii(inputText);
            if (result) {
                decodedText.textContent = result;
            } else {
                decodedText.textContent = '// No valid 8-bit binary groups found. Make sure to use spaces between 8-bit groups.';
            }
        };
    </script>
</body>
</html>